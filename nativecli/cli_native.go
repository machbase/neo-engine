//go:build !windows

package nativecli

/*
#cgo CFLAGS: -I${SRCDIR}/nativecli
#define ODBCVER 0x0380
#include <machbase_sqlcli.h>
#include <sql.h>
#include <stdlib.h>
#include <string.h>
*/
import "C"
import (
	"context"
	"database/sql"
	"encoding/hex"
	"errors"
	"fmt"
	"net"
	"reflect"
	"strings"
	"time"
	"unsafe"
)

func LinkInfo() string {
	return LibMachLinkInfo
}

type Env struct {
	handle     C.SQLHANDLE
	tz         *time.Location
	timeformat string
	host       string
	port       int
	user       string
	password   string
}

type EnvOption func(*Env)

func WithTimeLocation(tz *time.Location) EnvOption {
	return func(env *Env) {
		env.tz = tz
	}
}

func WithTimeformat(timeformat string) EnvOption {
	return func(env *Env) {
		env.timeformat = timeformat
	}
}

func WithHostPort(host string, port int) EnvOption {
	return func(env *Env) {
		env.host = host
		env.port = port
	}
}

func WithUser(user string) EnvOption {
	return func(env *Env) {
		env.user = user
	}
}

func WithPassword(password string) EnvOption {
	return func(env *Env) {
		env.password = password
	}
}

func WithUserPassword(user, password string) EnvOption {
	return func(env *Env) {
		env.user = user
		env.password = password
	}
}

func NewEnv(options ...EnvOption) (*Env, error) {
	env := &Env{
		timeformat: "2006-01-02 15:04:05.999",
		tz:         time.Local,
		host:       "127.0.0.1",
		port:       5656,
		user:       "sys",
		password:   "manager",
	}
	if v := C.SQLAllocEnv(&env.handle); v != 0 {
		return nil, fmt.Errorf("CLI_ERR SQLAllocEnv %d", v)
	}
	for _, opt := range options {
		opt(env)
	}
	return env, nil
}

func (env *Env) TimeLocation() *time.Location {
	return env.tz
}

func (env *Env) Timeofrmat() string {
	return env.timeformat
}

func (env *Env) HostPort() (string, int) {
	return env.host, env.port
}

func (env *Env) ConnectString() string {
	return fmt.Sprintf("SERVER=%s;UID=%s;PWD=%s;CONNTYPE=1;PORT_NO=%d",
		env.host, strings.ToUpper(env.user), strings.ToUpper(env.password), env.port)
}

func (env *Env) Close() error {
	if v := C.SQLFreeEnv(env.handle); v != 0 {
		return fmt.Errorf("CLI_ERR SQLFreeEnv %d", v)
	}
	return nil
}

func (env *Env) Error() *Error {
	return sqlError0(env.handle, nil, nil, "Env")
}

func (env *Env) SetTimeLocation(tz *time.Location) {
	env.tz = tz
}

type Conn struct {
	env    *Env
	handle C.SQLHANDLE
	ctx    context.Context
}

func (env *Env) Connect(ctx context.Context) (*Conn, error) {
	conn := &Conn{env: env, ctx: ctx}
	if v := C.SQLAllocConnect(env.handle, &conn.handle); v != 0 {
		return nil, fmt.Errorf("CLI_ERR SQLAllocConnect %d", v)
	}

	connStr := env.ConnectString()
	cConnStr := (*C.uchar)(unsafe.Pointer(C.CString(connStr)))
	defer func() {
		C.free(unsafe.Pointer(cConnStr))
	}()
	if v := C.SQLDriverConnect(conn.handle, nil, cConnStr,
		C.SQL_NTS, nil, 0, nil, C.SQL_DRIVER_NOPROMPT); v != 0 {
		return nil, conn.raiseError("SQLConnect", v)
	}
	return conn, nil
}

func (conn *Conn) Close() error {
	if v := C.SQLDisconnect(conn.handle); v != 0 {
		return conn.raiseError("SQLDisconnect", v)
	}
	if v := C.SQLFreeConnect(conn.handle); v != 0 {
		return conn.raiseError("SQLFreeConnect", v)
	}
	return nil
}

func (conn *Conn) ExecDirectContext(ctx context.Context, query string) error {
	stmt, err := conn.NewStmt()
	if err != nil {
		return err
	}
	defer stmt.Close()

	aQuery := (*C.uchar)(unsafe.Pointer(C.CString(query)))
	defer C.free(unsafe.Pointer(aQuery))

	if v := C.SQLExecDirect(stmt.handle, aQuery, C.SQL_NTS); v != 0 {
		return stmt.raiseError("SQLExecDirect", v)
	}
	return nil
}

func (conn *Conn) ExecContext(ctx context.Context, query string, args ...any) (*Result, error) {
	stmt, err := conn.NewStmt()
	if err != nil {
		return nil, err
	}
	defer stmt.Close()

	aQuery := (*C.uchar)(unsafe.Pointer(C.CString(query)))
	defer C.free(unsafe.Pointer(aQuery))

	if v := C.SQLPrepare(stmt.handle, aQuery, C.SQL_NTS); v != 0 {
		return nil, stmt.raiseError("SQLPrepare", v)
	}
	for i, p := range args {
		if err := stmt.Bind(i+1, p); err != nil {
			return nil, err
		}
	}
	if v := C.SQLExecute(stmt.handle); v != 0 {
		return nil, stmt.raiseError("SQLExecute", v)
	}
	ret := &Result{}
	C.SQLRowCount(stmt.handle, (*C.SQLLEN)(&ret.rowsAffected))
	return ret, nil
}

type Result struct {
	message      string
	rowsAffected int64
}

func (rs *Result) String() string {
	return rs.message
}

// LastInsertId returns the integer generated by the database
// in response to a command. Typically this will be from an
// "auto increment" column when inserting a new row. Not all
// databases support this feature, and the syntax of such
// statements varies.
func (rs *Result) LastInsertId() (int64, error) {
	return 0, ErrUnspported
}

// RowsAffected returns the number of rows affected by an
// update, insert, or delete. Not every database or database
// driver may support this.
func (rs *Result) RowsAffected() (int64, error) {
	return rs.rowsAffected, nil
}

func (conn *Conn) QueryRowContext(ctx context.Context, query string, args ...any) *Row {
	row := &Row{}
	stmt, err := conn.NewStmt()
	if err != nil {
		row.err = err
		return row
	}
	defer stmt.Close()

	aQuery := (*C.uchar)(unsafe.Pointer(C.CString(query)))
	defer C.free(unsafe.Pointer(aQuery))

	if v := C.SQLPrepare(stmt.handle, aQuery, C.SQL_NTS); v != 0 {
		row.err = stmt.raiseError("SQLPrepare", v)
		return row
	}
	for i, p := range args {
		if err := stmt.Bind(i+1, p); err != nil {
			row.err = err
			return row
		}
	}
	if v := C.SQLExecute(stmt.handle); v != 0 {
		row.err = stmt.raiseError("SQLExecute", v)
		return row
	}

	var columnCount C.short
	if v := C.SQLNumResultCols(stmt.handle, &columnCount); v != 0 {
		row.err = stmt.raiseError("SQLNumResultCols", v)
		return row
	}
	for colNum := 1; colNum <= int(columnCount); colNum++ {
		if col, err := stmt.DescribeCol(colNum); err != nil {
			row.err = err
			return row
		} else {
			row.columns = append(row.columns, col)
		}
	}
	// Fetch the next rowset of data from the result set and return it
	ret := C.SQLFetch(stmt.handle)
	if ret == C.SQL_NO_DATA {
		row.err = ErrNoRows
		return row
	} else if ret != C.SQL_SUCCESS && ret != C.SQL_SUCCESS_WITH_INFO {
		row.err = stmt.raiseError("SQLFetch", ret)
		return row
	}

	// Get the data from the colums
	for _, col := range row.columns {
		if v, err := col.getData(stmt); err != nil {
			row.err = err
			return row
		} else {
			row.values = append(row.values, v)
		}
	}
	return row
}

type Row struct {
	err     error
	columns []*ColumnType
	values  []*ColumnValue
}

func (ro *Row) Err() error {
	return ro.err
}

func (ro *Row) Scan(dest ...any) error {
	if len(ro.values) == 0 {
		return ErrNoRows
	}
	for i, vv := range dest {
		if i >= len(ro.values) {
			break
		}
		if err := ro.values[i].Scan(vv); err != nil {
			return err
		}
	}
	return nil
}

func (conn *Conn) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error) {
	stmt, err := conn.NewStmt()
	if err != nil {
		return nil, err
	}

	aQuery := (*C.SQLCHAR)(unsafe.Pointer(C.CString(query)))
	defer C.free(unsafe.Pointer(aQuery))

	if v := C.SQLPrepare(stmt.handle, aQuery, C.SQL_NTS); v != C.SQL_SUCCESS {
		stmt.Close()
		return nil, stmt.raiseError("SQLPrepare", v)
	}
	for i, p := range args {
		if err := stmt.Bind(i+1, p); err != nil {
			return nil, err
		}
	}
	if v := C.SQLExecute(stmt.handle); v != C.SQL_SUCCESS {
		stmt.Close()
		return nil, stmt.raiseError("SQLExecute", v)
	}

	var columnCount C.short
	if v := C.SQLNumResultCols(stmt.handle, &columnCount); v != 0 {
		stmt.Close()
		return nil, stmt.raiseError("SQLNumResultCols", v)
	}

	rows := &Rows{stmt: stmt}
	for colNum := 1; colNum <= int(columnCount); colNum++ {
		if col, err := stmt.DescribeCol(colNum); err != nil {
			return nil, err
		} else {
			rows.columns = append(rows.columns, col)
		}
	}
	return rows, nil
}

type Rows struct {
	err     error
	stmt    *Stmt
	columns []*ColumnType
	values  []*ColumnValue
}

func (rs *Rows) Err() error {
	return rs.err
}

func (rs *Rows) Close() error {
	if rs.stmt != nil {
		if err := rs.stmt.Close(); err != nil {
			return err
		}
	}
	return nil
}

func (rs *Rows) ColumnTypes() ([]*ColumnType, error) {
	return rs.columns, nil
}

func (rs *Rows) Columns() ([]string, error) {
	ret := []string{}
	for _, col := range rs.columns {
		ret = append(ret, col.name)
	}
	return ret, nil
}

func (rs *Rows) Next() bool {
	rs.values = rs.values[0:0]
	ret := C.SQLFetch(rs.stmt.handle)
	if ret == C.SQL_NO_DATA {
		return false
	} else if ret != C.SQL_SUCCESS && ret != C.SQL_SUCCESS_WITH_INFO {
		rs.err = rs.stmt.raiseError("SQLFetch", ret)
		return false
	}

	// Get the data from the colums
	for _, col := range rs.columns {
		if v, err := col.getData(rs.stmt); err != nil {
			rs.err = err
			return false
		} else {
			rs.values = append(rs.values, v)
		}
	}

	return true
}

func (rs *Rows) NextResultSet() bool {
	return false
}

func (rs *Rows) Scan(dest ...any) error {
	if len(rs.values) == 0 {
		return ErrNoRows
	}
	for i, vv := range dest {
		if i >= len(rs.values) {
			break
		}
		if err := rs.values[i].Scan(vv); err != nil {
			return fmt.Errorf("%s at column %q", err.Error(), rs.columns[i].name)
		}
	}
	return nil
}

func (conn *Conn) raiseError(fname string, rv C.short) error {
	if sqlerr := sqlError0(conn.env.handle, conn.handle, nil, fname); sqlerr != nil {
		return sqlerr
	} else {
		return fmt.Errorf("ERR %s %d", fname, rv)
	}
}

type Stmt struct {
	conn   *Conn
	handle C.SQLHANDLE
}

func (conn *Conn) NewStmt() (*Stmt, error) {
	stmt := &Stmt{conn: conn}
	if v := C.SQLAllocStmt(conn.handle, &stmt.handle); v != 0 {
		return nil, conn.raiseError("SQLAllocStmt", v)
	}
	return stmt, nil
}

func (stmt *Stmt) Close() error {
	if v := C.SQLFreeStmt(stmt.handle, C.SQL_CLOSE); v != 0 {
		return stmt.raiseError("SQLFreeStmt", v)
	}
	return nil
}

func (stmt *Stmt) Bind(colNum int, val any) error {
	var sLen C.long
	var cType C.short
	var valPtr unsafe.Pointer
	var sqlType C.short
	var cbColDef C.ulong
	var ibScale C.short
	var cbValueMax C.long

	switch v := val.(type) {
	case int:
		cType = C.SQL_C_SLONG
		sqlType = C.SQL_INTEGER
		valPtr = unsafe.Pointer(&v)
	case int16:
		cType = C.SQL_C_SSHORT
		sqlType = C.SQL_SMALLINT
		valPtr = unsafe.Pointer(&v)
	case int32:
		cType = C.SQL_C_SLONG
		sqlType = C.SQL_INTEGER
		valPtr = unsafe.Pointer(&v)
	case int64:
		cType = C.SQL_C_SBIGINT
		sqlType = C.SQL_BIGINT
		valPtr = unsafe.Pointer(&v)
	case float32:
		cType = C.SQL_C_FLOAT
		sqlType = C.SQL_FLOAT
		valPtr = unsafe.Pointer(&v)
	case float64:
		cType = C.SQL_C_DOUBLE
		sqlType = C.SQL_DOUBLE
		valPtr = unsafe.Pointer(&v)
	case string:
		cType = C.SQL_C_CHAR
		sqlType = C.SQL_VARCHAR
		bstr := []byte(v)
		valPtr = unsafe.Pointer(&bstr[0])
		cbValueMax = C.long(len(bstr))
		sLen = C.long(len(bstr))
	case []byte:
		cType = C.SQL_C_BINARY
		sqlType = C.SQL_BINARY
		valPtr = unsafe.Pointer(&v[0])
		cbValueMax = C.long(len(v))
		sLen = C.long(len(v))
	case time.Time:
		cType = C.SQL_C_TIMESTAMP
		sqlType = C.SQL_TYPE_TIMESTAMP
		ts := C.SQL_TIMESTAMP_STRUCT{
			year:     C.SQLSMALLINT(v.Year()),
			month:    C.SQLUSMALLINT(v.Month()),
			day:      C.SQLUSMALLINT(v.Day()),
			hour:     C.SQLUSMALLINT(v.Hour()),
			minute:   C.SQLUSMALLINT(v.Minute()),
			second:   C.SQLUSMALLINT(v.Second()),
			fraction: C.SQLUINTEGER(v.Nanosecond()),
		}
		valPtr = unsafe.Pointer(&ts)
	case net.IP:
		if v4 := v.To4(); v4 != nil {
			cType = C.SQL_C_CHAR
			sqlType = C.SQL_IPV4
			cbValueMax = C.long(15)
			bstr := []byte(v4.String())
			fmt.Println("ipv6", v4.String())
			sLen = C.long(len(bstr))
			valPtr = unsafe.Pointer(&bstr[0])
		} else if v6 := v.To16(); v6 != nil {
			cType = C.SQL_C_CHAR
			sqlType = C.SQL_IPV6
			cbValueMax = C.long(45)
			bstr := []byte(v6.String())
			fmt.Println("ipv6", v6.String())
			sLen = C.long(len(bstr))
			valPtr = unsafe.Pointer(&bstr[0])
		} else {
			return errors.New("ERROR Bind unsupported IP type")
		}
	default:
		return fmt.Errorf("ERROR Bind unsupported type %T", val)
	}
	if v := C.SQLBindParameter(
		stmt.handle,          // statement
		C.ushort(colNum),     // param index
		C.SQL_PARAM_INPUT,    // param type
		cType,                // C type
		sqlType,              // SQL type
		cbColDef,             // cbColDef
		ibScale,              // ibScale
		C.SQLPOINTER(valPtr), // rgbValue
		cbValueMax,           // cbValueMax
		&sLen,                // pcbValue
	); v != C.SQL_SUCCESS && v != C.SQL_SUCCESS_WITH_INFO {
		return stmt.raiseError("SQLBindParameter", v)
	}
	return nil
}

func (stmt *Stmt) DescribeCol(colNum int) (*ColumnType, error) {
	var colNameLen C.short
	var colType C.short
	var colSize C.ulong
	var colScale C.short
	var nullable C.short
	var colNameBuff [256]C.char

	if v := C.SQLDescribeCol(
		stmt.handle,
		C.ushort(colNum),
		(*C.uchar)(unsafe.Pointer(&colNameBuff[0])),
		256,
		&colNameLen,
		&colType,
		&colSize,
		&colScale,
		&nullable,
	); v != 0 {
		return nil, stmt.raiseError("SQLDescribeCol", v)
	}
	colName := colNameBuff[0:colNameLen]
	col := &ColumnType{
		colNum:   int(colNum),
		name:     C.GoString(&colName[0]),
		sqlType:  int(colType),
		size:     int(colSize),
		scale:    int(colScale),
		nullable: int(nullable),
	}
	return col, nil
}

func (stmt *Stmt) raiseError(fname string, rv C.short) error {
	if sqlerr := sqlError0(stmt.conn.env.handle, stmt.conn.handle, stmt.handle, fname); sqlerr != nil {
		return sqlerr
	} else {
		return fmt.Errorf("ERR %s %d", fname, rv)
	}
}

type ColumnType struct {
	colNum   int
	name     string
	sqlType  int
	size     int
	scale    int
	nullable int
}

func (col *ColumnType) String() string {
	return fmt.Sprintf("ColNum=%d Name=%s SqlType=%d Size=%d Scale=%d Nullable=%d", col.colNum, col.name, col.sqlType, col.size, col.scale, col.nullable)
}

func (col *ColumnType) DatabaseTypeName() string {
	return "TODO"
}

func (col *ColumnType) DecimalSize() (precision int64, scale int64, ok bool) {
	return int64(col.size), int64(col.scale), true
}

func (col *ColumnType) Length() (length int64, ok bool) {
	return int64(col.size), true
}

func (col *ColumnType) Name() string {
	return col.name
}
func (col *ColumnType) Nullable() (nullable bool, ok bool) {
	return col.nullable == 1, true
}

func (col *ColumnType) ScanBuffer() any {
	switch col.sqlType {
	case C.SQL_VARCHAR:
		return new(string)
	case C.SQL_TYPE_TIMESTAMP:
		return new(time.Time)
	case C.SQL_DOUBLE:
		return new(float64)
	case C.SQL_BIGINT: // 64-bit signed integer
		return new(int64)
	case C.SQL_BINARY: // fixed-length binary data
		return new([]byte)
	case C.SQL_BIT: // 1-bit binary data
		return new(byte)
	case C.SQL_CHAR: //	Character string
		return new(string)
	case C.SQL_C_SLONG: // 32-bit signed integer
		return new(int)
	case C.SQL_C_SSHORT: // 16-bit signed integer
		return new(int16)
	case C.SQL_DATE: // Date
		return new(time.Time)
	case C.SQL_DECIMAL: // Fixed precision and scale number
		return new(float64)
	case C.SQL_FLOAT: // Single precision floating point number
		return new(float64)
	case C.SQL_GUID: // Globally unique identifier
		return new(string)
	case C.SQL_INTEGER: // 32-bit signed integer
		return new(int)
	case C.SQL_LONGVARBINARY: // Variable-length binary data
		return new([]byte)
	case C.SQL_LONGVARCHAR: // Variable-length character data
		return new(string)
	case C.SQL_NUMERIC: // Fixed precision and scale number
		return new(float64)
	case C.SQL_SMALLINT: // 16-bit signed integer
		return new(int16)
	case C.SQL_TIME: // Time
		return new(time.Time)
	case C.SQL_TIMESTAMP: // Date and time
		return new(time.Time)
	case C.SQL_TYPE_DATE: // Date
		return new(time.Time)
	case C.SQL_TYPE_TIME: // Time
		return new(time.Time)
	case C.SQL_TINYINT: // 8-bit signed integer
		return new(int8)
	case C.SQL_VARBINARY: // Variable-length binary data
		return new([]byte)
	case C.SQL_WCHAR: // Unicode character string
		return new(string)
	case C.SQL_WLONGVARCHAR: // Variable-length Unicode character data
		return new(string)
	case C.SQL_WVARCHAR: // Variable-length Unicode character data
		return new(string)
	default:
		return new(string)
	}
}

func (col *ColumnType) ScanType() reflect.Type {
	switch col.sqlType {
	case C.SQL_VARCHAR:
		return reflect.TypeOf(string(""))
	case C.SQL_TYPE_TIMESTAMP:
		return reflect.TypeOf(time.Time{})
	case C.SQL_DOUBLE:
		return reflect.TypeOf(float64(0))
	case C.SQL_BIGINT: // 64-bit signed integer
		return reflect.TypeOf(float64(0))
	case C.SQL_BINARY: // fixed-length binary data
		return reflect.TypeOf([]byte{})
	case C.SQL_BIT: // 1-bit binary data
		return reflect.TypeOf(byte(0))
	case C.SQL_CHAR: //	Character string
		return reflect.TypeOf(string(""))
	case C.SQL_C_SLONG: // 32-bit signed integer
		return reflect.TypeOf(int(0))
	case C.SQL_C_SSHORT: // 16-bit signed integer
		return reflect.TypeOf(int16(0))
	case C.SQL_DATE: // Date
		return reflect.TypeOf(time.Time{})
	case C.SQL_DECIMAL: // Fixed precision and scale number
		return reflect.TypeOf(float64(0))
	case C.SQL_FLOAT: // Single precision floating point number
		return reflect.TypeOf(float64(0))
	case C.SQL_GUID: // Globally unique identifier
		return reflect.TypeOf(string(""))
	case C.SQL_INTEGER: // 32-bit signed integer
		return reflect.TypeOf(int(0))
	case C.SQL_LONGVARBINARY: // Variable-length binary data
		return reflect.TypeOf([]byte{})
	case C.SQL_LONGVARCHAR: // Variable-length character data
		return reflect.TypeOf(string(""))
	case C.SQL_NUMERIC: // Fixed precision and scale number
		return reflect.TypeOf(float64(0))
	case C.SQL_SMALLINT: // 16-bit signed integer
		return reflect.TypeOf(int16(0))
	case C.SQL_TIME: // Time
		return reflect.TypeOf(time.Time{})
	case C.SQL_TIMESTAMP: // Date and time
		return reflect.TypeOf(time.Time{})
	case C.SQL_TYPE_DATE: // Date
		return reflect.TypeOf(time.Time{})
	case C.SQL_TYPE_TIME: // Time
		return reflect.TypeOf(time.Time{})
	case C.SQL_TINYINT: // 8-bit signed integer
		return reflect.TypeOf(int8(0))
	case C.SQL_VARBINARY: // Variable-length binary data
		return reflect.TypeOf([]byte{})
	case C.SQL_WCHAR: // Unicode character string
		return reflect.TypeOf(string(""))
	case C.SQL_WLONGVARCHAR: // Variable-length Unicode character data
		return reflect.TypeOf(string(""))
	case C.SQL_WVARCHAR: // Variable-length Unicode character data
		return reflect.TypeOf(string(""))
	default:
		return reflect.TypeOf(string(""))
	}
}

func (col *ColumnType) getData(stmt *Stmt) (*ColumnValue, error) {
	var ind C.SQLLEN
	var valueType int
	var valueBuffer unsafe.Pointer
	var valueBufferLen int
	ret := &ColumnValue{
		tz:         stmt.conn.env.tz,
		timeformat: stmt.conn.env.timeformat,
	}

	switch col.sqlType {
	case C.SQL_TYPE_TIMESTAMP:
		raw := C.SQL_TIMESTAMP_STRUCT{}
		valueType = C.SQL_C_TIMESTAMP
		valueBuffer = unsafe.Pointer(&raw)
		valueBufferLen = int(unsafe.Sizeof(raw))
		defer func() {
			ret.Type = "datetime"
			ret.Value = time.Date(int(raw.year), time.Month(raw.month), int(raw.day),
				int(raw.hour), int(raw.minute), int(raw.second), 0, stmt.conn.env.tz)
		}()
	case C.SQL_FLOAT: // Single precision floating point number
		raw := float32(0)
		valueType = C.SQL_C_FLOAT
		valueBuffer = unsafe.Pointer(&raw)
		valueBufferLen = int(unsafe.Sizeof(raw))
		defer func() {
			ret.Type = "float"
			ret.Value = raw
		}()
	case C.SQL_DOUBLE:
		raw := float64(0)
		valueType = C.SQL_C_DOUBLE
		valueBuffer = unsafe.Pointer(&raw)
		valueBufferLen = int(unsafe.Sizeof(raw))
		defer func() {
			ret.Type = "double"
			ret.Value = raw
		}()
	case C.SQL_SMALLINT: // 16-bit signed integer
		raw := int16(0)
		valueType = C.SQL_C_SSHORT
		valueBuffer = unsafe.Pointer(&raw)
		valueBufferLen = int(unsafe.Sizeof(raw))
		defer func() {
			ret.Type = "short"
			ret.Value = raw
		}()
	case C.SQL_BIGINT: // 64-bit signed integer
		raw := int64(0)
		valueType = C.SQL_C_SBIGINT
		valueBuffer = unsafe.Pointer(&raw)
		valueBufferLen = int(unsafe.Sizeof(raw))
		defer func() {
			ret.Type = "long"
			ret.Value = raw
		}()
	case C.SQL_INTEGER: // 32-bit signed integer
		raw := int(0)
		valueType = C.SQL_C_SLONG
		valueBuffer = unsafe.Pointer(&raw)
		valueBufferLen = int(unsafe.Sizeof(raw))
		defer func() {
			ret.Type = "int"
			ret.Value = raw
		}()
	case C.SQL_IPV4:
		raw := [16]byte{}
		valueType = C.SQL_C_CHAR
		valueBuffer = unsafe.Pointer(&raw)
		valueBufferLen = int(unsafe.Sizeof(raw))
		defer func() {
			ret.Type = "ipv4"
			if ind == -1 {
				ret.Value = nil
			} else {
				ret.Value = net.ParseIP(string(raw[:ind]))
			}
		}()
	case C.SQL_IPV6:
		raw := [45]byte{}
		valueType = C.SQL_C_CHAR
		valueBuffer = unsafe.Pointer(&raw)
		valueBufferLen = int(unsafe.Sizeof(raw))
		defer func() {
			ret.Type = "ipv6"
			if ind == -1 {
				ret.Value = nil
			} else {
				ret.Value = net.ParseIP(string(raw[:ind]))
			}
		}()
	case C.SQL_VARCHAR:
		raw := make([]byte, col.size)
		valueType = C.SQL_C_BINARY
		valueBuffer = unsafe.Pointer(&raw[0])
		valueBufferLen = col.size
		defer func() {
			ret.Type = "varchar"
			if ind == -1 {
				ret.Value = nil
			} else {
				ret.Value = string(raw[0:ind])
			}
		}()
	case C.SQL_TEXT:
		raw := make([]byte, col.size)
		valueType = C.SQL_C_BINARY
		valueBuffer = unsafe.Pointer(&raw[0])
		valueBufferLen = col.size
		defer func() {
			ret.Type = "text"
			if ind == -1 {
				ret.Value = nil
			} else {
				ret.Value = string(raw[0:ind])
			}
		}()
	case C.SQL_JSON:
		raw := make([]byte, col.size)
		valueType = C.SQL_C_BINARY
		valueBuffer = unsafe.Pointer(&raw[0])
		valueBufferLen = col.size
		defer func() {
			ret.Type = "json"
			if ind == -1 {
				ret.Value = nil
			} else {
				ret.Value = string(raw[0:ind])
			}
		}()
	case C.SQL_CLOB:
		raw := make([]byte, col.size)
		valueType = C.SQL_C_BINARY
		valueBuffer = unsafe.Pointer(&raw[0])
		valueBufferLen = col.size
		defer func() {
			ret.Type = "clob"
			if ind == -1 {
				ret.Value = nil
			} else {
				ret.Value = raw[0:ind]
			}
		}()
	case C.SQL_BLOB:
		raw := make([]byte, col.size)
		valueType = C.SQL_C_BINARY
		valueBuffer = unsafe.Pointer(&raw[0])
		valueBufferLen = col.size
		defer func() {
			ret.Type = "blob"
			if ind == -1 {
				ret.Value = nil
			} else {
				ret.Value = raw[0:ind]
			}
		}()
	case C.SQL_BINARY: // fixed-length binary data
		raw := make([]byte, col.size)
		valueType = C.SQL_C_BINARY
		valueBuffer = unsafe.Pointer(&raw[0])
		valueBufferLen = col.size
		defer func() {
			ret.Type = "binary"
			if ind == -1 {
				ret.Value = nil
			} else {
				ret.Value = raw[0:ind]
			}
		}()
	default:
		return nil, fmt.Errorf("ERROR unsupported type %d of column #%d", col.sqlType, col.colNum)
	}
	v := C.SQLGetData(
		stmt.handle,
		C.ushort(col.colNum),
		C.short(valueType),
		C.SQLPOINTER(valueBuffer),
		C.SQLLEN(valueBufferLen),
		&ind,
	)
	if v != C.SQL_SUCCESS && v != C.SQL_SUCCESS_WITH_INFO {
		return nil, stmt.raiseError("SQLGetData", v)
	}

	if ret.IsNull = ind == C.SQL_NULL_DATA; ret.IsNull {
		return ret, nil
	}
	return ret, nil
}

type ColumnValue struct {
	IsNull     bool
	Type       string
	Value      any
	tz         *time.Location
	timeformat string
}

func (cv *ColumnValue) String() string {
	if cv.IsNull {
		return fmt.Sprintf("Type=%s Value=<NULL>", cv.Type)
	} else {
		return fmt.Sprintf("Type=%s Value=%v", cv.Type, cv.Value)
	}
}

func (cv *ColumnValue) Scan(dest any) error {
	if cv.IsNull {
		switch v := dest.(type) {
		case *string:
			v = nil
		case *time.Time:
			v = nil
		case *float64, *float32, *int, *int8, *int16, *int32, *int64:
			v = nil
		case *[]byte:
			v = nil
		case *sql.NullBool:
			(*v).Valid = false
		case *sql.NullFloat64:
			(*v).Valid = false
		case *sql.NullString:
			(*v).Valid = false
		case *sql.NullTime:
			(*v).Valid = false
		case *sql.NullInt16:
			(*v).Valid = false
		case *sql.NullInt32:
			(*v).Valid = false
		case *sql.NullInt64:
			(*v).Valid = false
		case *sql.NullByte:
			(*v).Valid = false
		default:
			return ErrCannotConvertValue(cv.Value, v)
		}
		return nil
	}
	switch src := cv.Value.(type) {
	case string:
		switch dst := dest.(type) {
		case *string:
			*dst = src
		default:
			return ErrCannotConvertValue(src, dst)
		}
	case int8:
		switch dst := dest.(type) {
		case *byte:
			*dst = byte(src)
		case *int8:
			*dst = src
		case *int16:
			*dst = int16(src)
		case *int32:
			*dst = int32(src)
		case *int:
			*dst = int(src)
		case *string:
			*dst = fmt.Sprintf("%d", src)
		default:
			return ErrCannotConvertValue(src, dst)
		}
	case int16:
		switch dst := dest.(type) {
		case *int16:
			*dst = src
		case *int32:
			*dst = int32(src)
		case *int:
			*dst = int(src)
		case *int64:
			*dst = int64(src)
		case *string:
			*dst = fmt.Sprintf("%d", src)
		default:
			return ErrCannotConvertValue(src, dst)
		}
	case int32:
		switch dst := dest.(type) {
		case *int64:
			*dst = int64(src)
		case *int32:
			*dst = int32(src)
		case *int:
			*dst = int(src)
		case *string:
			*dst = fmt.Sprintf("%d", src)
		default:
			return ErrCannotConvertValue(src, dst)
		}
	case int:
		switch dst := dest.(type) {
		case *int64:
			*dst = int64(src)
		case *int32:
			*dst = int32(src)
		case *int:
			*dst = int(src)
		case *string:
			*dst = fmt.Sprintf("%d", src)
		default:
			return ErrCannotConvertValue(src, dst)
		}
	case int64:
		switch dst := dest.(type) {
		case *int64:
			*dst = src
		case *int32:
			*dst = int32(src)
		case *int:
			*dst = int(src)
		case *string:
			*dst = fmt.Sprintf("%d", src)
		default:
			return ErrCannotConvertValue(src, dst)
		}
	case time.Time:
		switch dst := dest.(type) {
		case *time.Time:
			*dst = src
		case *int64:
			*dst = src.UnixNano()
		case *string:
			*dst = src.In(cv.tz).Format(cv.timeformat)
		default:
			return ErrCannotConvertValue(src, dst)
		}
	case float32:
		switch dst := dest.(type) {
		case *float32:
			*dst = src
		case *float64:
			*dst = float64(src)
		case *string:
			*dst = fmt.Sprintf("%f", src)
		default:
			return ErrCannotConvertValue(src, dst)
		}
	case float64:
		switch dst := dest.(type) {
		case *float64:
			*dst = src
		case *string:
			*dst = fmt.Sprintf("%f", src)
		default:
			return ErrCannotConvertValue(src, dst)
		}
	case []byte:
		switch dst := dest.(type) {
		case *[]byte:
			*dst = src
		case *string:
			*dst = hex.EncodeToString(src)
		default:
			return ErrCannotConvertValue(src, dst)
		}
	case net.IP:
		switch dst := dest.(type) {
		case *net.IP:
			*dst = src
		case *string:
			*dst = src.String()
		default:
			return ErrCannotConvertValue(src, dst)
		}
	default:
		return ErrCannotConvertValue(src, dest)
	}
	return nil
}

type Appender struct {
	ctx                  context.Context
	stmt                 *Stmt
	tableName            string
	tableType            int // 0: LogTable, 6: TagTableType
	columns              []*ColumnType
	errorCheckCount      int
	prependValueProvider func() []any
}

type AppenderOption func(*Appender)

func WithErrorCheckCount(count int) AppenderOption {
	return func(apd *Appender) {
		apd.errorCheckCount = count
	}
}

func WithPrependValuesProvider(valueProvider func() []any) AppenderOption {
	return func(apd *Appender) {
		apd.prependValueProvider = valueProvider
	}
}

func (conn *Conn) AppendOpen(ctx context.Context, tableName string, options ...AppenderOption) (*Appender, error) {
	tableName = strings.ToUpper(tableName)
	apd := &Appender{ctx: ctx, tableName: tableName}
	for _, opt := range options {
		opt(apd)
	}

	if rows, err := conn.QueryContext(ctx, fmt.Sprintf("select * from %s limit 1", tableName)); err != nil {
		return nil, err
	} else {
		apd.columns = make([]*ColumnType, len(rows.columns))
		copy(apd.columns, rows.columns)
		rows.Close()
	}

	if row := conn.QueryRowContext(ctx, "select type from M$SYS_TABLES where name = ?", tableName); row.Err() != nil {
		return nil, row.Err()
	} else {
		row.Scan(&apd.tableType)
	}

	if stmt, err := conn.NewStmt(); err != nil {
		return nil, err
	} else {
		apd.stmt = stmt
	}
	cTableName := (*C.uchar)(unsafe.Pointer(C.CString(tableName)))
	defer func() {
		C.free(unsafe.Pointer(cTableName))
	}()
	if v := C.SQLAppendOpen(apd.stmt.handle, (*C.SQLCHAR)(cTableName), 1); v != 0 {
		return nil, apd.raiseError("SQLAppendOpen", v)
	}
	return apd, nil
}

func (apd *Appender) Flush() error {
	if v := C.SQLAppendFlush(apd.stmt.handle); v != 0 {
		return fmt.Errorf("CLI_ERR SQLAppendFlush %d", v)
	}
	return nil
}

func (apd *Appender) Close() (int64, int64, error) {
	var successCount C.long
	var failureCount C.long
	if v := C.SQLAppendClose(apd.stmt.handle, &successCount, &failureCount); v != 0 {
		return 0, 0, fmt.Errorf("CLI_ERR SQLAppendClose %d", v)
	}
	if err := apd.stmt.Close(); err != nil {
		return 0, 0, err
	}
	return int64(successCount), int64(failureCount), nil
}

func (apd *Appender) raiseError(fname string, rv C.short) error {
	if sqlerr := sqlError0(apd.stmt.conn.env.handle, apd.stmt.conn.handle, apd.stmt.handle, fname); sqlerr != nil {
		return sqlerr
	} else {
		return fmt.Errorf("CLI_ERR %s %d", fname, rv)
	}
}

func (apd *Appender) Append(values ...any) error {
	if apd.prependValueProvider != nil {
		values = append(apd.prependValueProvider(), values...)
	}
	if len(values) != len(apd.columns) {
		return fmt.Errorf("ERROR Append column count mismatch, expect: %d, actual: %d", len(apd.columns), len(values))
	}
	params := make([]C.machbaseAppendParam, len(values))
	for i, col := range apd.columns {
		pv := &params[i]
		switch col.sqlType {
		case C.SQL_TYPE_TIMESTAMP:
			switch val := values[i].(type) {
			case time.Time:
				((*C.machbaseAppendDateTimeStruct)(unsafe.Pointer(&pv[0]))).mTime = C.longlong(val.UnixNano())
			}
		case C.SQL_SMALLINT:
			switch val := values[i].(type) {
			case int8:
				*(*C.short)(unsafe.Pointer(&pv[0])) = C.short(int16(val))
			case int16:
				*(*C.short)(unsafe.Pointer(&pv[0])) = C.short(int16(val))
			case int32:
				*(*C.short)(unsafe.Pointer(&pv[0])) = C.short(int16(val))
			case int64:
				*(*C.short)(unsafe.Pointer(&pv[0])) = C.short(int16(val))
			case int:
				*(*C.short)(unsafe.Pointer(&pv[0])) = C.short(int16(val))
			default:
				return ErrAppendTypeNotImplement("SQL_SMALLINT", col.colNum, col.name, val)
			}
		case C.SQL_INTEGER:
			switch val := values[i].(type) {
			case int8:
				*(*C.int)(unsafe.Pointer(&pv[0])) = C.int(int(val))
			case int16:
				*(*C.int)(unsafe.Pointer(&pv[0])) = C.int(int(val))
			case int32:
				*(*C.int)(unsafe.Pointer(&pv[0])) = C.int(int(val))
			case int64:
				*(*C.int)(unsafe.Pointer(&pv[0])) = C.int(int(val))
			case int:
				*(*C.int)(unsafe.Pointer(&pv[0])) = C.int(int(val))
			default:
				return ErrAppendTypeNotImplement("SQL_SMALLINT", col.colNum, col.name, val)
			}
		case C.SQL_BIGINT:
			switch val := values[i].(type) {
			case int8:
				*(*C.long)(unsafe.Pointer(&pv[0])) = C.long(int64(val))
			case int16:
				*(*C.long)(unsafe.Pointer(&pv[0])) = C.long(int64(val))
			case int32:
				*(*C.long)(unsafe.Pointer(&pv[0])) = C.long(int64(val))
			case int64:
				*(*C.long)(unsafe.Pointer(&pv[0])) = C.long(int64(val))
			case int:
				*(*C.long)(unsafe.Pointer(&pv[0])) = C.long(int64(val))
			default:
				return ErrAppendTypeNotImplement("SQL_BIGINT", col.colNum, col.name, val)
			}
		case C.SQL_FLOAT:
			switch val := values[i].(type) {
			case float32:
				*(*C.float)(unsafe.Pointer(&pv[0])) = C.float(val)
			case float64:
				*(*C.float)(unsafe.Pointer(&pv[0])) = C.float(val)
			default:
				return ErrAppendTypeNotImplement("SQL_FLOAT", col.colNum, col.name, val)
			}
		case C.SQL_DOUBLE:
			switch val := values[i].(type) {
			case float32:
				*(*C.double)(unsafe.Pointer(&pv[0])) = C.double(val)
			case float64:
				*(*C.double)(unsafe.Pointer(&pv[0])) = C.double(val)
			default:
				return ErrAppendTypeNotImplement("SQL_DOUBLE", col.colNum, col.name, val)
			}
		case C.SQL_IPV4:
			var addr net.IP
			switch val := values[i].(type) {
			case net.IP:
				addr = val
			case string:
				addr = net.ParseIP(val)
			case []byte:
				addr = net.IP(val)
			default:
				return ErrAppendTypeNotImplement("SQL_IPV4", col.colNum, col.name, val)
			}
			if v4 := addr.To4(); v4 != nil {
				for i := 0; i < 4; i++ {
					(*C.machbaseAppendIPStruct)(unsafe.Pointer(&pv[0])).mAddr[i] = C.uchar(v4[i])
				}
				(*C.machbaseAppendIPStruct)(unsafe.Pointer(&pv[0])).mLength = C.uchar(4)
				(*C.machbaseAppendIPStruct)(unsafe.Pointer(&pv[0])).mAddrString = nil
			} else {
				return errors.New("ERROR Append unsupported IPv4 type")
			}
		case C.SQL_IPV6:
			var addr net.IP
			switch val := values[i].(type) {
			case net.IP:
				addr = val
			case string:
				addr = net.ParseIP(val)
			case []byte:
				addr = net.IP(val)
			default:
				return ErrAppendTypeNotImplement("SQL_IPV6", col.colNum, col.name, val)
			}
			if v6 := addr.To16(); v6 != nil {
				for i := 0; i < 16; i++ {
					(*C.machbaseAppendIPStruct)(unsafe.Pointer(&pv[0])).mAddr[i] = C.uchar(v6[i])
				}
				(*C.machbaseAppendIPStruct)(unsafe.Pointer(&pv[0])).mLength = C.uchar(6)
				(*C.machbaseAppendIPStruct)(unsafe.Pointer(&pv[0])).mAddrString = nil
			} else {
				return errors.New("ERROR Append unsupported IPv6 type")
			}
		case C.SQL_VARCHAR, C.SQL_TEXT, C.SQL_CLOB, C.SQL_JSON:
			switch val := values[i].(type) {
			case string:
				cstr := C.CString(val)
				cstrLen := C.strlen(cstr)
				defer C.free(unsafe.Pointer(cstr))
				((*C.machbaseAppendVarStruct)(unsafe.Pointer(&pv[0]))).mData = unsafe.Pointer(cstr)
				((*C.machbaseAppendVarStruct)(unsafe.Pointer(&pv[0]))).mLength = C.uint(cstrLen)
			case []byte:
				((*C.machbaseAppendVarStruct)(unsafe.Pointer(&pv[0]))).mData = unsafe.Pointer(&val[0])
				((*C.machbaseAppendVarStruct)(unsafe.Pointer(&pv[0]))).mLength = C.uint(len(val))
			default:
				return ErrAppendTypeNotImplement("SQL_VARCHAR", col.colNum, col.name, val)
			}
		case C.SQL_BINARY:
			switch val := values[i].(type) {
			case string:
				cstr := C.CString(val)
				cstrLen := C.strlen(cstr)
				defer C.free(unsafe.Pointer(cstr))
				((*C.machbaseAppendVarStruct)(unsafe.Pointer(&pv[0]))).mData = unsafe.Pointer(cstr)
				((*C.machbaseAppendVarStruct)(unsafe.Pointer(&pv[0]))).mLength = C.uint(cstrLen)
			case []byte:
				((*C.machbaseAppendVarStruct)(unsafe.Pointer(&pv[0]))).mData = unsafe.Pointer(&val[0])
				((*C.machbaseAppendVarStruct)(unsafe.Pointer(&pv[0]))).mLength = C.uint(len(val))
			default:
				return ErrAppendTypeNotImplement("SQL_Text", col.colNum, col.name, val)
			}
		default:
			return fmt.Errorf("ERROR Append unimplemented for type %d of column #%d (%+v)", col.sqlType, col.colNum, col)
		}
	}
	if v := C.SQLAppendDataV2(apd.stmt.handle, &params[0]); v != 0 {
		return apd.stmt.raiseError("SQLAppendDataV2", v)
	}
	return nil
}

type Error struct {
	code     int
	message  string
	sqlState string
	caller   string
}

func sqlError0(env C.SQLHANDLE, conn C.SQLHANDLE, stmt C.SQLHANDLE, caller string) *Error {
	sErrorMsg := make([]C.uchar, C.SQL_MAX_MESSAGE_LENGTH+1)
	sSqlState := make([]C.uchar, C.SQL_SQLSTATE_SIZE+1)
	var sNativeError C.int
	var sMsgLength C.short
	if v := C.SQLError(env, conn, stmt, &sSqlState[0], &sNativeError,
		&sErrorMsg[0], C.SQL_MAX_MESSAGE_LENGTH, &sMsgLength); v == 0 {
		state := ""
		if sSqlState[0] != 0 {
			state = string(sSqlState[0:C.SQL_SQLSTATE_SIZE])
		}
		return &Error{
			code:     int(sNativeError),
			message:  string(sErrorMsg[0:sMsgLength]),
			sqlState: state,
			caller:   caller,
		}
	}
	return nil
}

func (e *Error) Error() string {
	if e.sqlState == "" {
		return fmt.Sprintf("SQLERR-%d %s caused by %s", e.code, e.message, e.caller)
	} else {
		return fmt.Sprintf("SQLERR-%d %s %s caused by %s", e.code, e.sqlState, e.message, e.caller)
	}
}

func (e *Error) String() string {
	return e.Error()
}

var ErrUnspported = errors.New("unsupported")
var ErrNoRows = errors.New("no rows in result set")
var ErrCannotConvertValue = func(from, to any) error { return fmt.Errorf("cannot convert value from %T to %T", from, to) }
var ErrAppendTypeNotImplement = func(typ string, colNum int, colName string, val any) error {
	return fmt.Errorf("Append not implemented for type %s of column #%d %q from %T", typ, colNum, colName, val)
}
